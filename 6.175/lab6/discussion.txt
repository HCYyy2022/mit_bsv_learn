//****************************************************************************************************************//
//**  Discussion Question 1 (10 Points): Debugging practice!
//**  
//**  If you replace the BTB with a simple pc + 4 address prediction, the processor still works, but it does not perform as well.
//**  If you replace it with a really bad predictor that predicts pc is the next instruction for each pc, it should still work but 
//**  have even worse performance because each instruction would require redirection (unless the instruction loops back to itself).
//**  If you actually set the prediction to pc, you will get errors in the assembly tests; the first one will be from cache.riscv.vmh.
//**  
//**  What is the error you get?
//**  What is happening in the processor to cause that to happen?
//**  Why do not you get this error with PC+4 and BTB predictors?
//**  How would you fix it?
//**  You do not actually have to fix this bug, just answer the questions. (Hint: look at the addr field of ExecInst structure.)
//****************************************************************************************************************//
(1) ERROR: Executing unsupported instruction at pc: 00004000. Exiting
(2) 
    1) When executing the instruction: sw x3, 0(x1), the calculated eInst.addr is aluRes, which is rVal1 + aluVal2, with a value of 0x4000.
    2) When branch prediction fails, eInst.addr is used as the address for repairing the jump.
    3) Therefore, using 0x4000 as the new jump address here is incorrect.
    
(3)The instruction "sw x3, 0(x1)" does not generate a branch. When using pc+4 or BTB as the predictor,
pc+4 will be used as the next branch prediction address, which is correct. Therefore, there will be no
need for prediction address correction, and the issue mentioned will not occur.

(4) Modify Exec.bsv to use pc+4 as the result of eInst.addr when the instruction is sw.


//****************************************************************************************************************//
//** Discussion Question 2 (5 Points): What evidence do you have that all pipeline stages can fire in the same cycle?
//****************************************************************************************************************//
evidence 1: I have printed out the detailed execution process of each phase in each cycle. The printed result for a certain
cycle is as follows:
    # Cycle          4 ----------------------------------------------------
    # [Fetch] : PC = 00000214
    # [Decode]: PC = 00000210, inst = 00000013, expanded = addi r 0 = r 0 0x0
    # [RegFetch]: PC = 0000020c, insert sb = 00
    # [Execute] : PC = 00000208
    # [Memory] : valid eInst, PC = 00000204
    # [WriteBack] :  valid eInst, PC = 00000200, remove sb

evidence 2: In the simple test, 104 cycles were performed with 100 instructions executed.


//****************************************************************************************************************//
//** Discussion Question 3 (5 Points): In your six-stage pipelined processor, how many cycles does it take to correct
//** a mispredicted instruction?
//****************************************************************************************************************//
four

//****************************************************************************************************************//
//** Discussion Question 4 (5 Points): If an instruction depends on the result of the instruction immediately before
//** it in the pipeline, how many cycles is that instruction stalled?
//****************************************************************************************************************//
four

//****************************************************************************************************************//
//** Discussion Question 5 (5 Points): What IPC do you get for each benchmark?
//****************************************************************************************************************//
(1) Benchmark median
Cycles = 9899
Insts  = 4243
IPC = 4243 / 9899 = 0.4286

(2) Benchmark multiply
Cycles = 33540
Insts  = 20893
IPC = 20893 / 33540 = 0.6229

(3) Benchmark qsort
Cycles = 300387
Insts  = 123496
IPC = 123496 / 300387 = 0.4111


(4) Benchmark tower
Cycles = 6219
Insts  = 4168
IPC = 4168 / 6219 = 0.6702

(5) Benchmark vvadd
Cycles = 3621
Insts  = 2408
IPC = 2408 / 3621 = 0.6650